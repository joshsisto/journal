# Apple Calendar Integration Plan for Journal Application

This report outlines the steps required to integrate Apple Calendar functionality into the existing Flask-based journaling application. The primary method for integration will be through the CalDAV protocol, as Apple does not provide a public REST API for iCloud Calendar.

## 1. Understanding Apple Calendar Integration

*   **CalDAV Protocol:** Apple Calendar (iCloud Calendar) primarily uses CalDAV (Calendaring Extensions to WebDAV) for synchronization. CalDAV is an open standard that allows clients to access and manage calendar data on a remote server.
*   **App-Specific Passwords:** To access iCloud Calendar via CalDAV, users must generate an app-specific password from their Apple ID account page. This enhances security by providing a unique password for each application, which can be revoked without compromising the main Apple ID password.

## 2. Prerequisites

*   **Python Libraries:**
    *   `caldav`: A Python library for interacting with CalDAV servers. This will be the primary library for calendar operations.
    *   `requests`: (Likely a dependency of `caldav`, but good to note) for HTTP requests.
*   **User Authentication:** The application must securely store and use the user's Apple ID (email) and the generated app-specific password.

## 3. High-Level Integration Steps

1.  **User Interface for Credentials:** Add a section in the user settings (e.g., `templates/settings.html`) to allow users to input their Apple ID and app-specific password.
2.  **Secure Credential Storage:** Store the encrypted Apple ID and app-specific password in the application's database (`models.py`).
3.  **CalDAV Client Initialization:** Create a utility function or service to initialize the `caldav` client using the stored credentials.
4.  **Calendar Listing:** Implement functionality to fetch and display a list of the user's available calendars.
5.  **Event Synchronization (Optional/Manual):** Allow users to import events from Apple Calendar into their journal or export journal entries to Apple Calendar. This could be a manual trigger or a background task.
6.  **Displaying Calendar Data:** Integrate Apple Calendar events into the dashboard or a dedicated calendar view.
7.  **Error Handling:** Implement robust error handling for network issues, invalid credentials, and CalDAV specific errors.

## 4. Detailed Steps (Code-Level Considerations)

### 4.1. Database Schema Modifications (`models.py`)

*   **User Model Extension:** Add fields to the `User` model to store Apple ID and the encrypted app-specific password.
    ```python
    # In models.py
    class User(db.Model):
        # ... existing fields ...
        apple_id = db.Column(db.String(120), unique=True, nullable=True)
        apple_app_specific_password_hash = db.Column(db.String(256), nullable=True) # Store hashed/encrypted
    ```
*   **Encryption:** Use a strong encryption method (e.g., Flask-Security's `encrypt_password` or a custom encryption utility) to store the app-specific password. Do NOT store it in plain text.

### 4.2. User Interface for Credentials (`templates/settings.html`, `forms.py`, `routes.py`)

*   **Form Definition (`forms.py`):** Create a new Flask-WTF form for Apple Calendar settings.
    ```python
    # In forms.py
    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, SubmitField
    from wtforms.validators import Email, Optional

    class AppleCalendarSettingsForm(FlaskForm):
        apple_id = StringField('Apple ID (Email)', validators=[Optional(), Email()])
        app_specific_password = PasswordField('App-Specific Password', validators=[Optional()])
        submit = SubmitField('Save Apple Calendar Settings')
    ```
*   **Settings Template (`templates/settings.html`):** Add a section to the settings page to render this form.
    ```html
    <!-- In templates/settings.html -->
    <h3>Apple Calendar Integration</h3>
    <form method="POST" action="{{ url_for('auth.apple_calendar_settings') }}">
        {{ form.hidden_tag() }}
        <p>
            {{ form.apple_id.label }}<br>
            {{ form.apple_id(size=32) }}
            {% for error in form.apple_id.errors %}
                <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>
            {{ form.app_specific_password.label }}<br>
            {{ form.app_specific_password(size=32) }}
            {% for error in form.app_specific_password.errors %}
                <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>{{ form.submit() }}</p>
    </form>
    ```
*   **Route Handling (`routes.py` - within auth blueprint or new blueprint):** Create a route to handle the form submission, encrypt the password, and save it to the user's profile.
    ```python
    # In routes.py (or a new apple_calendar_bp)
    from flask import Blueprint, render_template, redirect, url_for, flash, current_app
    from flask_login import login_required, current_user
    from werkzeug.security import generate_password_hash, check_password_hash # For password hashing
    from .forms import AppleCalendarSettingsForm
    from .models import db # Assuming db is imported from models

    apple_calendar_bp = Blueprint('apple_calendar', __name__)

    @apple_calendar_bp.route('/settings/apple_calendar', methods=['GET', 'POST'])
    @login_required
    def apple_calendar_settings():
        form = AppleCalendarSettingsForm()
        if form.validate_on_submit():
            current_user.apple_id = form.apple_id.data
            if form.app_specific_password.data: # Only update if provided
                current_user.apple_app_specific_password_hash = generate_password_hash(form.app_specific_password.data)
            db.session.commit()
            flash('Apple Calendar settings updated successfully!', 'success')
            return redirect(url_for('main.settings')) # Assuming 'main.settings' is your settings page
        elif request.method == 'GET':
            form.apple_id.data = current_user.apple_id
            # Do not pre-fill password for security reasons
        return render_template('settings.html', form=form) # Pass the form to the settings template
    ```
    *   **Note:** You'll need to register this blueprint in `app.py`.

### 4.3. CalDAV Client Utility (`services/apple_calendar_service.py` - new file)

Create a new service file to encapsulate CalDAV interactions.

```python
# In services/apple_calendar_service.py
import caldav
from caldav.elements import dav, cdav
from urllib.parse import urlparse

class AppleCalendarService:
    def __init__(self, apple_id, app_specific_password):
        self.apple_id = apple_id
        self.app_specific_password = app_specific_password
        self.client = None
        self.principal = None

    def _get_client(self):
        if not self.client:
            # Apple CalDAV server URL
            # This might vary, but caldav.icloud.com is common.
            # The library might handle discovery, but explicit is safer.
            # A common principal URL for iCloud is https://caldav.icloud.com/
            # The library should handle finding the principal from the base URL.
            try:
                self.client = caldav.DAVClient(
                    url="https://caldav.icloud.com/",
                    username=self.apple_id,
                    password=self.app_specific_password
                )
                self.principal = self.client.principal()
            except caldav.lib.error.AuthorizationError:
                raise ValueError("Invalid Apple ID or App-Specific Password.")
            except Exception as e:
                raise RuntimeError(f"Failed to connect to CalDAV server: {e}")
        return self.client, self.principal

    def get_calendars(self):
        try:
            _, principal = self._get_client()
            return principal.calendars()
        except Exception as e:
            current_app.logger.error(f"Error fetching calendars for {self.apple_id}: {e}")
            return []

    def get_events(self, calendar, start_date=None, end_date=None):
        try:
            # Example: Fetching events from a calendar
            # You might need to adjust the date filtering based on caldav library capabilities
            events = calendar.events()
            # Further filter by start_date and end_date if needed
            return events
        except Exception as e:
            current_app.logger.error(f"Error fetching events from calendar {calendar.name} for {self.apple_id}: {e}")
            return []

    def create_event(self, calendar, summary, description=None, dtstart=None, dtend=None):
        try:
            # Example: Creating a new event
            # dtstart and dtend should be datetime objects
            event = calendar.add_event(
                summary=summary,
                description=description,
                dtstart=dtstart,
                dtend=dtend
            )
            return event
        except Exception as e:
            current_app.logger.error(f"Error creating event in calendar {calendar.name} for {self.apple_id}: {e}")
            return None

    # Add methods for update_event, delete_event as needed
```

### 4.4. Integrating with Existing Routes (`routes.py`, `services/journal_service.py`)

*   **Dashboard/Journal View:**
    *   Modify the dashboard route (`routes.py`) to fetch and display Apple Calendar events alongside journal entries.
    *   You'll need to instantiate `AppleCalendarService` using the current user's credentials.
    *   Consider adding a filter or toggle to show/hide calendar events.
    ```python
    # In routes.py (journal blueprint or main blueprint)
    from .services.apple_calendar_service import AppleCalendarService

    @main_bp.route('/dashboard') # Assuming this is your dashboard route
    @login_required
    def dashboard():
        # ... existing journal entry fetching logic ...

        apple_calendar_events = []
        if current_user.apple_id and current_user.apple_app_specific_password_hash:
            try:
                # Decrypt password before passing to service
                app_specific_password = check_password_hash(current_user.apple_app_specific_password_hash, 'password_to_check_against') # This needs to be handled carefully, perhaps decrypt on demand
                # A better approach would be to decrypt the password when needed and pass it to the service.
                # For demonstration, assuming check_password_hash is used for verification, not decryption.
                # You'll need a proper decryption mechanism if you hash it. If you encrypt, you'll need to decrypt.
                # For now, let's assume the hash is directly the encrypted password for simplicity in this plan.
                # In a real app, you'd use a symmetric encryption key stored securely.

                # For the purpose of this plan, let's assume a direct decryption function exists:
                # decrypted_password = decrypt_password(current_user.apple_app_specific_password_hash)
                # For now, let's just use the hash as if it were the decrypted password for the example.
                # THIS IS NOT SECURE. YOU MUST IMPLEMENT PROPER ENCRYPTION/DECRYPTION.
                decrypted_password = current_user.apple_app_specific_password_hash # Placeholder for actual decryption

                apple_service = AppleCalendarService(current_user.apple_id, decrypted_password)
                calendars = apple_service.get_calendars()
                for calendar in calendars:
                    # You might want to let the user select which calendars to sync
                    events = apple_service.get_events(calendar)
                    apple_calendar_events.extend(events)
            except ValueError as e:
                flash(f"Apple Calendar Error: {e}", 'danger')
            except RuntimeError as e:
                flash(f"Apple Calendar Connection Error: {e}", 'danger')
            except Exception as e:
                flash(f"An unexpected error occurred with Apple Calendar: {e}", 'danger')

        return render_template('dashboard.html', journal_entries=journal_entries, apple_calendar_events=apple_calendar_events)
    ```
    *   **Note on Password Handling:** The example above for `decrypted_password` is a placeholder. **You MUST implement a secure method for encrypting and decrypting the app-specific password.** Storing it as a hash (like `generate_password_hash`) is for verification, not for decryption. You'll need a proper symmetric encryption scheme (e.g., using `cryptography` library) with a securely managed key.

### 4.5. Error Handling and User Feedback

*   Use Flask's `flash` messages to inform users about successful operations or errors (e.g., invalid credentials, connection issues).
*   Implement `try-except` blocks around all CalDAV interactions to catch `caldav.lib.error.AuthorizationError` for credential issues and general `Exception` for other network or server problems.

### 4.6. Background Tasks (Optional, for continuous sync)

If you want continuous synchronization of events, consider using a task queue like Celery with Redis or RabbitMQ.

*   **Celery Setup:**
    *   Install `celery` and a broker (e.g., `redis`).
    *   Configure Celery in `app.py`.
*   **Scheduled Task:** Create a Celery task to periodically fetch events from Apple Calendar and update the local database.
    ```python
    # In tasks.py (new file)
    from celery import Celery
    from app import create_app # Assuming create_app is your app factory
    from services.apple_calendar_service import AppleCalendarService
    from models import User, db # Assuming db is imported from models

    celery_app = Celery('journal_app', broker='redis://localhost:6379/0') # Configure your broker

    @celery_app.task
    def sync_apple_calendar_for_user(user_id):
        app = create_app() # Create app context for database access
        with app.app_context():
            user = User.query.get(user_id)
            if user and user.apple_id and user.apple_app_specific_password_hash:
                try:
                    # Decrypt password securely here
                    decrypted_password = user.apple_app_specific_password_hash # Placeholder
                    apple_service = AppleCalendarService(user.apple_id, decrypted_password)
                    calendars = apple_service.get_calendars()
                    for calendar in calendars:
                        events = apple_service.get_events(calendar)
                        # Process events: store in local DB, update existing, etc.
                        # Example: log event summaries
                        for event in events:
                            current_app.logger.info(f"Synced event: {event.summary} from {user.apple_id}")
                except Exception as e:
                    current_app.logger.error(f"Failed to sync Apple Calendar for user {user_id}: {e}")

    # Schedule this task (e.g., in app.py or a separate scheduler)
    # from celery.schedules import crontab
    # celery_app.conf.beat_schedule = {
    #     'sync-apple-calendars-every-hour': {
    #         'task': 'tasks.sync_apple_calendar_for_user',
    #         'schedule': crontab(minute=0), # Run every hour
    #         'args': (user.id,) # Pass user ID to the task
    #     },
    # }
    ```

### 4.7. Testing

*   **Unit Tests:** Test the `AppleCalendarService` methods in isolation (mocking CalDAV responses).
*   **Integration Tests:** Test the full flow from UI input to database storage and CalDAV interaction (using a test Apple ID and app-specific password, or a mock CalDAV server).
*   **Security Tests:** Verify that credentials are encrypted correctly and not exposed.

## 5. Security Considerations

*   **App-Specific Passwords:** Educate users on how to generate and use app-specific passwords.
*   **Encryption at Rest:** **Crucially, encrypt the app-specific password before storing it in the database.** Use a robust encryption library (e.g., `cryptography.fernet`) and ensure the encryption key is securely managed (e.g., via environment variables, not hardcoded).
*   **Encryption in Transit:** CalDAV communication should always happen over HTTPS to protect credentials and data during transmission. The `caldav` library should handle this by default when using `https://` URLs.
*   **Rate Limiting:** Implement rate limiting on CalDAV requests to avoid being blocked by Apple's servers.
*   **Error Handling:** Gracefully handle authentication failures and other API errors without exposing sensitive information.
*   **Revocation:** Provide a way for users to revoke their Apple Calendar integration, which should clear their stored credentials.

By following these steps, you can successfully integrate Apple Calendar functionality into your journal application, allowing users to manage and view their calendar events within your platform.